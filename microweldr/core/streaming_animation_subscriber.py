"""Streaming animation subscriber that generates SVG animations incrementally."""

import logging
from pathlib import Path
from typing import List, Optional, TextIO, Dict, Any
from .events import Event, EventType, OutputEvent, publish_event
from .subscribers import EventSubscriber

logger = logging.getLogger(__name__)


class StreamingAnimationSubscriber(EventSubscriber):
    """Generates SVG animation output from events in streaming mode.

    This subscriber writes SVG animation incrementally as events flow through the system,
    eliminating the need to store WeldPath objects in memory.
    """

    def __init__(self, output_path: Path, config):
        """Initialize streaming animation subscriber."""
        self.output_path = Path(output_path)
        self.config = config
        self.file_handle: Optional[TextIO] = None
        self.current_path_id = ""
        self.current_weld_type = "normal"
        self.current_path_points = []
        self.total_paths_processed = 0
        self.total_points_processed = 0
        self.is_initialized = False
        self.overall_bounds = {
            "min_x": None,
            "min_y": None,
            "max_x": None,
            "max_y": None,
        }

    def get_priority(self) -> int:
        """Get subscriber priority (lower number = higher priority)."""
        return 25  # Lower priority - after validation, bounding box, and G-code

    def get_subscribed_events(self) -> List[EventType]:
        """Get subscribed event types."""
        return [EventType.PATH_PROCESSING, EventType.OUTPUT_GENERATION]

    def handle_event(self, event: Event) -> None:
        """Handle events for streaming animation generation."""
        try:
            if event.event_type == EventType.PATH_PROCESSING:
                self._handle_path_event(event)
            elif event.event_type == EventType.OUTPUT_GENERATION:
                self._handle_output_event(event)
        except Exception as e:
            logger.exception(f"Error in streaming animation subscriber: {e}")

    def _handle_path_event(self, event: Event) -> None:
        """Handle path processing event - streaming mode."""
        action = event.data.get("action", "")

        if action == "path_start":
            path_data = event.data.get("path_data", {})
            self.current_path_id = path_data.get(
                "id", f"path_{self.total_paths_processed}"
            )
            self.current_weld_type = path_data.get("weld_type", "normal")
            self.current_path_points = []

            # Initialize SVG file if not already done
            if not self.file_handle:
                self._initialize_svg_file()

            logger.debug(f"StreamingAnimation: Started path {self.current_path_id}")

        elif action == "point_added":
            point_data = event.data.get("point_data", {})
            x = point_data.get("x", 0)
            y = point_data.get("y", 0)
            point_weld_type = point_data.get("weld_type", self.current_weld_type)

            # Store point for path completion
            self.current_path_points.append(
                {"x": x, "y": y, "weld_type": point_weld_type}
            )
            self.total_points_processed += 1

            # Update bounds for SVG viewBox
            self._update_bounds(x, y)

        elif action == "path_complete":
            # Write complete path to SVG
            if self.current_path_points and self.file_handle:
                self._write_path_svg()

            self.current_path_points = []
            self.total_paths_processed += 1
            logger.debug(f"StreamingAnimation: Completed path {self.current_path_id}")

    def _handle_output_event(self, event: Event) -> None:
        """Handle output generation event."""
        action = event.data.get("action", "")
        output_type = event.data.get("output_type", "")

        if action == "generate" and output_type in ["animation", "png"]:
            self._finalize_svg_file()

    def _initialize_svg_file(self) -> None:
        """Initialize SVG file with header (will be updated with final viewBox)."""
        try:
            self.file_handle = open(self.output_path, "w", encoding="utf-8")
            # Write placeholder header - will be updated when we know the bounds
            self.file_handle.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            self.file_handle.write(
                "<!-- SVG Animation generated by MicroWeldr - Streaming Mode -->\n"
            )
            # Placeholder for SVG tag - will be written in finalize
            self.is_initialized = True
            logger.info(f"StreamingAnimation: Initialized SVG file {self.output_path}")
        except Exception as e:
            logger.error(f"Failed to initialize SVG file {self.output_path}: {e}")
            raise

    def _update_bounds(self, x: float, y: float) -> None:
        """Update bounding box for SVG viewBox calculation."""
        if self.overall_bounds["min_x"] is None or x < self.overall_bounds["min_x"]:
            self.overall_bounds["min_x"] = x
        if self.overall_bounds["max_x"] is None or x > self.overall_bounds["max_x"]:
            self.overall_bounds["max_x"] = x
        if self.overall_bounds["min_y"] is None or y < self.overall_bounds["min_y"]:
            self.overall_bounds["min_y"] = y
        if self.overall_bounds["max_y"] is None or y > self.overall_bounds["max_y"]:
            self.overall_bounds["max_y"] = y

    def _write_path_svg(self) -> None:
        """Write SVG path element for current path."""
        if not self.file_handle or not self.current_path_points:
            return

        # Generate path data
        path_data = self._generate_path_data()

        # Get color based on weld type
        color = self._get_weld_type_color(self.current_weld_type)

        # Write path element
        self.file_handle.write(f'  <path id="{self.current_path_id}" ')
        self.file_handle.write(f'd="{path_data}" ')
        self.file_handle.write(f'stroke="{color}" ')
        self.file_handle.write('stroke-width="0.5" ')
        self.file_handle.write('fill="none" ')
        self.file_handle.write('opacity="0">\n')

        # Add animation
        self._write_path_animation()

        self.file_handle.write("  </path>\n")

    def _generate_path_data(self) -> str:
        """Generate SVG path data string from points."""
        if not self.current_path_points:
            return ""

        path_parts = []
        first_point = self.current_path_points[0]
        path_parts.append(f"M {first_point['x']:.3f} {first_point['y']:.3f}")

        for point in self.current_path_points[1:]:
            path_parts.append(f"L {point['x']:.3f} {point['y']:.3f}")

        return " ".join(path_parts)

    def _get_weld_type_color(self, weld_type: str) -> str:
        """Get color for weld type."""
        colors = {
            "normal": "#ff0000",  # Red
            "frangible": "#ff8800",  # Orange
            "stop": "#0000ff",  # Blue
            "pipette": "#00ff00",  # Green
        }
        return colors.get(weld_type, "#ff0000")

    def _write_path_animation(self) -> None:
        """Write SVG animation elements for the path."""
        if not self.file_handle:
            return

        # Calculate animation timing
        base_delay = self.total_paths_processed * 0.5  # Stagger path animations
        duration = len(self.current_path_points) * 0.1  # Duration based on point count

        # Fade in animation
        self.file_handle.write(f'    <animate attributeName="opacity" ')
        self.file_handle.write(f'values="0;1" ')
        self.file_handle.write(f'dur="{duration:.1f}s" ')
        self.file_handle.write(f'begin="{base_delay:.1f}s" ')
        self.file_handle.write('fill="freeze"/>\n')

        # Path drawing animation
        path_length = self._estimate_path_length()
        self.file_handle.write(f'    <animate attributeName="stroke-dasharray" ')
        self.file_handle.write(f'values="0 {path_length:.1f};{path_length:.1f} 0" ')
        self.file_handle.write(f'dur="{duration:.1f}s" ')
        self.file_handle.write(f'begin="{base_delay:.1f}s" ')
        self.file_handle.write('fill="freeze"/>\n')

    def _estimate_path_length(self) -> float:
        """Estimate total path length for animation."""
        if len(self.current_path_points) < 2:
            return 10.0  # Default length

        total_length = 0.0
        for i in range(1, len(self.current_path_points)):
            p1 = self.current_path_points[i - 1]
            p2 = self.current_path_points[i]
            dx = p2["x"] - p1["x"]
            dy = p2["y"] - p1["y"]
            total_length += (dx * dx + dy * dy) ** 0.5

        return max(total_length, 10.0)  # Minimum length for visibility

    def _finalize_svg_file(self) -> None:
        """Finalize SVG file with proper header and close."""
        if not self.file_handle:
            return

        # Read current content
        self.file_handle.close()

        # Read the file content
        with open(self.output_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Calculate viewBox
        viewbox = self._calculate_viewbox()

        # Write final file with proper SVG header
        with open(self.output_path, "w", encoding="utf-8") as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            f.write("<!-- SVG Animation generated by MicroWeldr - Streaming Mode -->\n")
            f.write(f'<svg xmlns="http://www.w3.org/2000/svg" ')
            f.write(f'viewBox="{viewbox}" ')
            f.write(f'width="800" height="600">\n')
            f.write("  <title>MicroWeldr Animation</title>\n")
            f.write("  <desc>Animated welding path visualization</desc>\n")
            f.write("\n")

            # Write the paths (skip the placeholder header lines)
            lines = content.split("\n")
            for line in lines:
                if (
                    line.strip()
                    and not line.startswith("<?xml")
                    and not line.startswith("<!--")
                ):
                    f.write(line + "\n")

            f.write("</svg>\n")

        self.file_handle = None

        logger.info(f"StreamingAnimation: Finalized SVG file {self.output_path}")
        logger.info(
            f"StreamingAnimation: Processed {self.total_paths_processed} paths, {self.total_points_processed} points"
        )

        # Publish completion event
        publish_event(
            OutputEvent(
                action="complete",
                output_type="animation",
                file_path=self.output_path,
                statistics={
                    "total_paths": self.total_paths_processed,
                    "total_points": self.total_points_processed,
                    "file_size": (
                        self.output_path.stat().st_size
                        if self.output_path.exists()
                        else 0
                    ),
                    "viewbox": viewbox,
                },
            )
        )

    def _calculate_viewbox(self) -> str:
        """Calculate SVG viewBox from bounds."""
        if not all(v is not None for v in self.overall_bounds.values()):
            return "0 0 100 100"  # Default viewBox

        min_x = self.overall_bounds["min_x"]
        min_y = self.overall_bounds["min_y"]
        max_x = self.overall_bounds["max_x"]
        max_y = self.overall_bounds["max_y"]

        # Add padding
        padding = max((max_x - min_x) * 0.1, (max_y - min_y) * 0.1, 5.0)

        viewbox_x = min_x - padding
        viewbox_y = min_y - padding
        viewbox_width = (max_x - min_x) + (2 * padding)
        viewbox_height = (max_y - min_y) + (2 * padding)

        return (
            f"{viewbox_x:.1f} {viewbox_y:.1f} {viewbox_width:.1f} {viewbox_height:.1f}"
        )

    def get_statistics(self) -> Dict[str, Any]:
        """Get animation generation statistics."""
        return {
            "total_paths_processed": self.total_paths_processed,
            "total_points_processed": self.total_points_processed,
            "output_file": str(self.output_path),
            "file_exists": self.output_path.exists(),
            "file_size": (
                self.output_path.stat().st_size if self.output_path.exists() else 0
            ),
            "is_initialized": self.is_initialized,
            "bounds": self.overall_bounds.copy(),
        }

    def __del__(self):
        """Ensure file is closed on cleanup."""
        if self.file_handle:
            try:
                self.file_handle.close()
            except:
                pass
