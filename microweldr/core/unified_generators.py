"""Unified generators for two-phase architecture."""

import logging
from pathlib import Path
from typing import Dict, Any, Optional, TextIO

logger = logging.getLogger(__name__)


class GCodeGenerator:
    """Unified G-code generator for two-phase architecture."""

    def __init__(
        self, output_path: Path, bounds: Dict[str, float], config: Dict[str, Any]
    ):
        """Initialize G-code generator."""
        self.output_path = output_path
        self.bounds = bounds
        self.config = config
        self.file_handle: Optional[TextIO] = None
        self.total_points = 0
        self.current_path_id = ""
        self.is_first_point_in_path = True

        # G-code settings from config
        movement_config = config.get("movement", {})
        self.safe_height = movement_config.get("move_height", 5.0)
        self.weld_height = movement_config.get(
            "weld_height", 0.02
        )  # Height for actual welding
        self.weld_move_height = movement_config.get(
            "weld_move_height", 0.52
        )  # Height for moving between welds

        self.travel_speed = movement_config.get("travel_speed", 3000)
        self.weld_time = 100  # milliseconds

        # Calculate centering offset from bed size and frame bounds
        printer_config = config.get("printer", {})
        bed_size_x = printer_config.get("bed_size_x", 250.0)
        bed_size_y = printer_config.get("bed_size_y", 220.0)

        # Get actual design bounds and center
        design_center_x = bounds.get("center_x", 0)
        design_center_y = bounds.get("center_y", 0)
        frame_width = bounds.get("width", 0)
        frame_height = bounds.get("height", 0)

        # Calculate bed center
        bed_center_x = bed_size_x / 2
        bed_center_y = bed_size_y / 2

        # Center the design on the bed by moving design center to bed center
        self.offset_x = bed_center_x - design_center_x
        self.offset_y = bed_center_y - design_center_y

        logger.debug(
            f"G-code centering: bed={bed_size_x}×{bed_size_y}, design_center=({design_center_x:.1f},{design_center_y:.1f}), bed_center=({bed_center_x:.1f},{bed_center_y:.1f}), offset=({self.offset_x:.1f},{self.offset_y:.1f})"
        )

        # Open file and write header
        self._initialize_file()

    def _initialize_file(self) -> None:
        """Initialize G-code file with header."""
        try:
            self.file_handle = open(self.output_path, "w", encoding="utf-8")

            # Write G-code header
            self.file_handle.write(
                "; Generated by MicroWeldr - Two-Phase Architecture\n"
            )
            self.file_handle.write(f"; Output file: {self.output_path.name}\n")
            self.file_handle.write(
                f"; Frame bounds: {self.bounds['width']:.1f} × {self.bounds['height']:.1f}\n"
            )
            self.file_handle.write(
                f"; Centered at offset: ({self.offset_x:.1f}, {self.offset_y:.1f})\n"
            )
            self.file_handle.write(f"; Weld height: {self.weld_height:.3f}mm\n")
            self.file_handle.write(
                f"; Weld move height: {self.weld_move_height:.3f}mm\n"
            )
            self.file_handle.write("; \n")
            self.file_handle.write("; Prusa Core One Plastic Welding G-code\n")
            self.file_handle.write("; \n\n")

            # Printer initialization
            self.file_handle.write("; Printer initialization\n")
            self.file_handle.write("G90 ; Absolute positioning\n")
            self.file_handle.write("G28 ; Home all axes\n")
            self.file_handle.write("M83 ; Relative extrusion\n\n")

            # Set and wait for temperatures
            temperatures_config = self.config.get("temperatures", {})
            bed_temp = temperatures_config.get("bed_temperature", 35)
            nozzle_temp = temperatures_config.get("nozzle_temperature", 160)

            self.file_handle.write("; Set temperatures and wait\n")
            self.file_handle.write(
                f"M190 S{bed_temp} ; Set bed temperature to {bed_temp}°C and wait\n"
            )
            self.file_handle.write(
                f"M109 S{nozzle_temp} ; Set nozzle temperature to {nozzle_temp}°C and wait\n"
            )
            self.file_handle.write("M117 Temperatures reached - ready to weld\n\n")

            logger.debug(f"Initialized G-code file: {self.output_path}")

        except Exception as e:
            logger.error(f"Failed to initialize G-code file: {e}")
            raise

    def add_point(self, point: Dict[str, Any]) -> None:
        """Add a point and generate G-code immediately."""
        if not self.file_handle:
            return

        x = point.get("x", 0)
        y = point.get("y", 0)
        weld_type = point.get("weld_type", "normal")
        path_id = point.get("path_id", "unknown")

        # Check if we're starting a new path
        if path_id != self.current_path_id:
            if self.current_path_id:  # Complete previous path
                self.file_handle.write(f"; Completed path: {self.current_path_id}\n\n")

            # Start new path
            self.current_path_id = path_id
            self.is_first_point_in_path = True
            self.file_handle.write(f"; Starting path: {path_id} ({weld_type})\n")

        # Generate G-code for this point
        self._write_point_gcode(x, y, weld_type)
        self.total_points += 1
        self.is_first_point_in_path = False

    def _write_point_gcode(self, x: float, y: float, weld_type: str) -> None:
        """Write G-code commands for a single point."""
        if not self.file_handle:
            return

        # Apply centering offset to coordinates
        centered_x = x + self.offset_x
        centered_y = y + self.offset_y

        if self.is_first_point_in_path:
            # Move to safe height, then to start position
            self.file_handle.write(
                f"G1 Z{self.safe_height:.1f} F600 ; Move to safe height\n"
            )
            self.file_handle.write(
                f"G1 X{centered_x:.3f} Y{centered_y:.3f} F{self.travel_speed} ; Move to start of path\n"
            )
        else:
            # Move to weld move height (faster), then to next position
            self.file_handle.write(
                f"G1 Z{self.weld_move_height:.3f} F300 ; Raise to weld move height\n"
            )
            self.file_handle.write(
                f"G1 X{centered_x:.3f} Y{centered_y:.3f} F{self.travel_speed} ; Move to next point\n"
            )

        # Perform welding operation
        if weld_type != "stop":  # Don't weld on stop points
            self.file_handle.write(
                f"G1 Z{self.weld_height:.2f} F300 ; Lower to weld height\n"
            )
            self.file_handle.write(
                f"G4 P{self.weld_time} ; Weld for {self.weld_time/1000:.1f}s\n"
            )

        # Flush to ensure data is written immediately
        self.file_handle.flush()

    def finalize(self) -> Dict[str, Any]:
        """Finalize G-code file and close it."""
        if not self.file_handle:
            return {"success": False, "error": "File not initialized"}

        try:
            # Complete final path
            if self.current_path_id:
                self.file_handle.write(
                    f"G1 Z{self.safe_height:.1f} F300 ; Raise to safe height\n"
                )
                self.file_handle.write(f"; Completed path: {self.current_path_id}\n\n")

            # Write footer
            self.file_handle.write("; End of welding sequence\n")
            self.file_handle.write("G28 ; Home all axes\n")
            self.file_handle.write("M84 ; Disable steppers\n")
            self.file_handle.write(f"; Total points processed: {self.total_points}\n")
            self.file_handle.write("; End of G-code\n")

            self.file_handle.close()
            self.file_handle = None

            logger.info(
                f"G-code generation complete: {self.output_path} ({self.total_points} points)"
            )

            return {
                "success": True,
                "output_path": self.output_path,
                "total_points": self.total_points,
                "bounds": self.bounds,
            }

        except Exception as e:
            logger.error(f"Error finalizing G-code file: {e}")
            return {"success": False, "error": str(e)}

    def __del__(self):
        """Ensure file is closed on cleanup."""
        if self.file_handle:
            try:
                self.file_handle.close()
            except:
                pass


class SVGGenerator:
    """Unified SVG animation generator for two-phase architecture."""

    def __init__(
        self, output_path: Path, bounds: Dict[str, float], config: Dict[str, Any]
    ):
        """Initialize SVG generator."""
        self.output_path = output_path
        self.bounds = bounds
        self.config = config
        self.points = []

        logger.info(f"SVG generator initialized: {output_path}")

    def add_point(self, point: Dict[str, Any]) -> None:
        """Collect points for SVG generation."""
        self.points.append(point)

    def finalize(self) -> Dict[str, Any]:
        """Generate SVG using collected points."""
        try:
            # Convert points back to WeldPath format for existing SVG generator
            weld_paths = self._convert_points_to_weld_paths(self.points)

            # Use existing animation generator
            from ..animation.generator import AnimationGenerator
            from ..core.config import Config

            # Create Config object from dict
            config_obj = Config()
            config_obj._config = self.config

            animation_generator = AnimationGenerator(config_obj)
            animation_generator.generate_file(weld_paths, self.output_path)

            logger.info(f"SVG generation complete: {self.output_path}")

            return {
                "success": True,
                "output_path": self.output_path,
                "total_points": len(self.points),
            }
        except Exception as e:
            logger.error(f"SVG generation failed: {e}")
            return {"success": False, "error": str(e)}

    def _convert_points_to_weld_paths(self, points):
        """Convert collected points back to WeldPath objects."""
        from ..core.models import WeldPath, WeldPoint

        # Group points by path_id
        paths_dict = {}
        for point in points:
            path_id = point["path_id"]
            if path_id not in paths_dict:
                paths_dict[path_id] = []
            paths_dict[path_id].append(point)

        # Create WeldPath objects
        weld_paths = []
        for path_id, path_points in paths_dict.items():
            weld_points = []
            for pt in path_points:
                weld_point = WeldPoint(x=pt["x"], y=pt["y"], weld_type=pt["weld_type"])
                weld_points.append(weld_point)

            # Create WeldPath with first point's weld_type as default
            path_weld_type = path_points[0]["weld_type"] if path_points else "normal"
            weld_path = WeldPath(
                points=weld_points, weld_type=path_weld_type, svg_id=path_id
            )
            weld_paths.append(weld_path)

        return weld_paths


class PNGGenerator:
    """Unified PNG animation generator for two-phase architecture."""

    def __init__(
        self, output_path: Path, bounds: Dict[str, float], config: Dict[str, Any]
    ):
        """Initialize PNG generator."""
        self.output_path = output_path
        self.bounds = bounds
        self.config = config
        self.points = []

        logger.info(f"PNG generator initialized: {output_path}")

    def add_point(self, point: Dict[str, Any]) -> None:
        """Collect points for PNG generation."""
        self.points.append(point)

    def finalize(self) -> Dict[str, Any]:
        """Generate PNG using collected points."""
        try:
            # Convert points back to WeldPath format for existing PNG generator
            weld_paths = self._convert_points_to_weld_paths(self.points)

            # Use existing animation generator
            from ..animation.generator import AnimationGenerator
            from ..core.config import Config

            # Create Config object from dict
            config_obj = Config()
            config_obj._config = self.config

            animation_generator = AnimationGenerator(config_obj)
            animation_generator.generate_png_file(weld_paths, self.output_path)

            logger.info(f"PNG generation complete: {self.output_path}")

            return {
                "success": True,
                "output_path": self.output_path,
                "total_points": len(self.points),
            }
        except Exception as e:
            logger.error(f"PNG generation failed: {e}")
            return {"success": False, "error": str(e)}

    def _convert_points_to_weld_paths(self, points):
        """Convert collected points back to WeldPath objects."""
        from ..core.models import WeldPath, WeldPoint

        # Group points by path_id
        paths_dict = {}
        for point in points:
            path_id = point["path_id"]
            if path_id not in paths_dict:
                paths_dict[path_id] = []
            paths_dict[path_id].append(point)

        # Create WeldPath objects
        weld_paths = []
        for path_id, path_points in paths_dict.items():
            weld_points = []
            for pt in path_points:
                weld_point = WeldPoint(x=pt["x"], y=pt["y"], weld_type=pt["weld_type"])
                weld_points.append(weld_point)

            # Create WeldPath with first point's weld_type as default
            path_weld_type = path_points[0]["weld_type"] if path_points else "normal"
            weld_path = WeldPath(
                points=weld_points, weld_type=path_weld_type, svg_id=path_id
            )
            weld_paths.append(weld_path)

        return weld_paths
